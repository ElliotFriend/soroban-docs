---
sidebar_position: 0
title: Introduction
---

## Goals

Soroban-RPC can be simply described as a "live network gateway for Soroban." It provides information that the network currently has in its view (i.e. current state). It also has the ability to send a transaction to the network, and query the network for the status of previously sent transactions. It is meant to be simple, minimal, scalable, and familiar to blockchain developers from other ecosystems.

Soroban-RPC should provide all the basic data that a dapp developer would need, provided they are:

- Only interested in current state data, or are willing to ingest events into their own infrastructure to support reporting/analytics queries.
  - Caveat: Soroban-RPC should provide enough data-retention to support reliable ingestion of events.
- Only interested in building and submitting Soroban transactions (not Stellar Vanilla).

Soroban-RPC should support the developer from local testing (via the quickstart image), all the way through to production deployments.

- This implies it should be easy to deploy, and easy to maintain; with low cost, and little "admin" needed.
- The developer should be able to simply run the quickstart docker image, and quickly be ready to serve requests without needing to set up or maintain dependent infrastructure.

## Anti-Goals

- Soroban-RPC is not a Horizon replacement. Horizon is better suited for historical reporting and analytics queries. Horizon is more concerned with Stellar Vanilla data.
- Soroban-RPC should not depend on Horizon. Horizon is expensive and difficult to run, so if Soroban-RPC depended on Horizon, it would inherit that.
- Soroban-RPC should also provide an API basis for infrastructure providers to implement, but not necessarily be an off-the-shelf solution for them.
- Soroban-RPC is not a reporting/analytics tool and does not provide thorough historical data querying. It does not provide any data aggregation, compilations, or multi-server coordination requests.
- Soroban-RPC does not target ultra-low latency. The latency should be low enough to build and submit successful soroban transactions, but supporting high-frequency traders is not the goal.

<!-- TODO: Decide on direct exposure support (i.e. should we support exposing soroban-rpc directly to the internet?). People will do it regardless, so it might be best to... -->

## JSON-RPC

Soroban-RPC will accept HTTP POST requests using the [JSON-RPC 2.0] specification. Errors are returned via the [jsonrpc error object] wherever possible (and makes sense).

For production and other publicly-accessible instances, the JSON-RPC endpoint should be served over SSL on port 443, where possible, for security and ease of use. Though, soroban-rpc does not terminate ssl by itself, so will need a load-balancer or other service to terminate SSL for it.

To interact with soroban-rpc from inside a JavaScript application, use the [js-soroban-client] library, which gives a convenient interface for the RPC methods.

When XDR is passed as a parameter or returned, it is always a string encoded using standard base64.

## Pagination

Pagination in soroban-rpc is similar to pagination in Horizon.

For methods which support it, the pagination arguments are passed as a final object argument with two values:

- `cursor`: string - (optional) A number that points to a specific location in a collection of responses and is pulled from the paging_token value of a record.
- `limit`: number - (optional) The maximum number of records returned. The limit can range from 1 to 200 - an upper limit that is hardcoded in Soroban-RPC for performance reasons. If this argument isn't designated, it defaults to 10.

For example, calling a method with pagination parameter set:

```json
{
  "jsonrpc": "2.0",
  "Id": "1",
  "method": "exampleMethod",
  "params": [
    "other",
    "arguments",
    { "cursor": "1234-1", "limit": 100 }
  ]
}
```

## Outstanding Questions

- Do we need:
  - classic asset info?
    - Yes, for import/export
  - dedicated network fees query? or is preflight enough?
  - Client authentication options, i.e. OAuth, Basic, something to protect the service from anonymous abuse.
- Should we also include a strval-style json-ified version of the xdr?
  - in returns? in params? both?
  - It's easier for humans to read/understand, which helps with client-debugging.
  - Conversion to/from xdr.ScVal is lossy.
  - Seems unnecessary. Clients will already have the xdr lib, so can convert it themselves if needed.

[JSON-RPC 2.0]: <https://www.jsonrpc.org/specification>
[jsonrpc error object]: <https://www.jsonrpc.org/specification#error_object>
[js-soroban-client]: <https://github.com/stellar/js-soroban-client>
